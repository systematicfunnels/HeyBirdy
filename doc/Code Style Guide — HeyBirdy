Below is a **practical, opinionated Code Style Guide** for **HeyBirdy**, written to keep your codebase:

* readable for first-time contributors
* consistent across frontend + backend
* scalable as the team grows
* aligned with **progressive capability architecture**

This is **not theoretical** ‚Äî it‚Äôs meant to be enforced in code reviews.

---

# üßë‚Äçüíª Code Style Guide ‚Äî HeyBirdy

> **Core Principle**
> Code should explain **intent**, not just logic.
> If a new engineer can‚Äôt understand it in 5 minutes, it‚Äôs wrong.

---

## 1Ô∏è‚É£ General Engineering Principles (Non-Negotiable)

1. **Readability over cleverness**
2. **Explicit > implicit**
3. **Capabilities > roles**
4. **Events > side effects**
5. **Small files > large files**
6. **Consistency beats preference**

---

## 2Ô∏è‚É£ Naming Conventions (CRITICAL)

### Files & Folders

* `kebab-case` for folders
* `camelCase` for variables/functions
* `PascalCase` for React components & classes

```
/affiliate-links
/user-profile
/create-content.ts
ShareEarnButton.tsx
```

---

### Variables & Functions

‚ùå Bad

```ts
let flag = true;
```

‚úÖ Good

```ts
let isAffiliateActive = true;
```

Names must explain **why**, not just **what**.

---

### Capabilities (NEVER call them roles)

‚ùå

```ts
user.role === "affiliate"
```

‚úÖ

```ts
user.capabilities.isAffiliate
```

This rule is strict.

---

## 3Ô∏è‚É£ Frontend Code Style (Next.js / React)

### Component Rules

* One component = one responsibility
* No business logic inside UI components
* UI reads state, does not decide permissions

#### Good Pattern

```tsx
if (user.capabilities.isAffiliate) {
  return <AffiliateDashboard />;
}
```

‚ùå Bad Pattern

```tsx
if (user.role === "affiliate") {
  ...
}
```

---

### Folder Structure (Frontend)

```
/components
  /content
  /affiliate
  /creator
  /shared

/hooks
/store
/services
```

* `components` ‚Üí UI only
* `services` ‚Üí API calls
* `hooks` ‚Üí logic & orchestration

---

### State Management Rules

* **Zustand** ‚Üí user, capabilities, UI state
* **React Query** ‚Üí server state
* Never mix both responsibilities

---

## 4Ô∏è‚É£ Backend Code Style (Node / API)

### API Handler Rules

1. Validate input first
2. Check capability second
3. Perform action
4. Emit event
5. Return response

#### Example

```ts
if (!user.capabilities.isCreator) {
  throw new ForbiddenError(
    "Complete your profile to start creating content"
  );
}
```

‚ùå Never return silent 403s
‚ùå Never let frontend guess what to do next

---

### Service Layer Pattern

```
Controller ‚Üí Service ‚Üí Repository ‚Üí DB
```

Business logic **never** goes into controllers.

---

## 5Ô∏è‚É£ Database & Data Layer Style

### Table Naming

* plural, snake_case

```
users
affiliate_links
content_access
```

---

### Columns

* snake_case
* explicit booleans

‚ùå

```sql
active
```

‚úÖ

```sql
is_affiliate_enabled
```

---

## 6Ô∏è‚É£ Event Naming & Handling

### Event Names

* past tense
* snake_case

```
affiliate_activated
content_shared
commission_earned
```

---

### Event Rules

* Events are immutable
* Never emit events from UI
* Backend only

---

## 7Ô∏è‚É£ Error Handling Style

### Error Responses MUST:

1. Explain what happened
2. Explain what to do next

#### Example

```json
{
  "error": "AFFILIATE_NOT_ACTIVE",
  "message": "Enable affiliate sharing to generate links."
}
```

‚ùå No generic errors
‚ùå No ‚ÄúUnauthorized‚Äù without context

---

## 8Ô∏è‚É£ Comments & Documentation

### When to Comment

* Why something exists
* Why a decision was made

‚ùå Don‚Äôt comment obvious code

‚úÖ Good comment

```ts
// We activate affiliate capability here because
// user intent is explicit via Share & Earn click
```

---

### File Headers (Only for Complex Logic)

```ts
/**
 * Handles affiliate commission attribution.
 * Must remain idempotent.
 * Triggered by purchase_completed events.
 */
```

---

## 9Ô∏è‚É£ Formatting Rules (Automated)

### Required Tools

* **Prettier** (formatting)
* **ESLint** (rules)
* **Husky** (pre-commit)
* **lint-staged**

### Formatting Rules

* 2 spaces
* max line length: 100
* trailing commas
* semicolons required

No debates ‚Äî auto-format only.

---

## üîê 10Ô∏è‚É£ Security-First Coding Rules

* Never trust client data
* Never calculate earnings on frontend
* Never expose internal IDs publicly
* Use UUIDs for public references

---

## 11Ô∏è‚É£ Code Review Checklist (MANDATORY)

Every PR must answer:

* [ ] Is capability logic correct?
* [ ] Is user intent clear?
* [ ] Are events emitted properly?
* [ ] Is error guidance helpful?
* [ ] Could a junior engineer understand this?

If not ‚Üí reject PR.

---

## 12Ô∏è‚É£ What We Explicitly Avoid

‚ùå God components
‚ùå Role-based conditionals
‚ùå Magic numbers
‚ùå Hard-coded permissions
‚ùå Silent failures

---

## üß† Final Code Philosophy (Lock This)

> **HeyBirdy‚Äôs code should read like a story of user intent ‚Äî
> not a puzzle of permissions.**

If the code tells the story clearly:

* bugs reduce
* onboarding speeds up
* scale becomes possible

---

## ‚úÖ Summary (Pin This)

* Capabilities, not roles
* Intent-based logic
* Event-driven side effects
* Explicit errors
* Consistent structure

---

If you want next, I can:

* Generate **ESLint + Prettier config**
* Create **backend folder template**
* Write **example PRs**
* Define **commit message conventions**
* Create **engineering onboarding doc**

Just tell me üëç

